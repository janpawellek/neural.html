<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>neural.html</title>
    </head>
    <body>
        <div id="main">
            <h1>neural.html</h1>
            <h2>a neural network that lives in a single HTML page</h2>
        </div>
        <script>
            "use strict";
            var HelperFunctions,
                ActivationFunctions,
                Layer,
                NeuralNetwork;

            // Object that stores some helper functions
            HelperFunctions = {
                // calculates the outer product ab^T for two vectors a and b
                outerProduct: function(a, b) {
                    var n,
                        p,
                        result = new Array(a.length);
                    for (n = 0; n < a.length; n++) {
                        result[n] = new Array(b.length);
                        for (p = 0; p < b.length; p++) {
                            result[n][p] = a[n] * b[p];
                        }
                    }
                    return result;
                },

                // calculates the inner product a^Tb for a matrix a and a vector b
                innerProduct: function(a, b) {
                    var n,
                        p,
                        result = new Array(a[0].length);
                    for (n = 0; n < a[0].length; n++) {
                        result[n] = 0;
                        for (p = 0; p < b.length; p++) {
                            result[n] += a[p][n] * b[p];
                        }
                    }
                    return result;
                }
            };

            // Object that stores different activation functions
            ActivationFunctions = {
                sigmoid: {
                    calc: function(x) {
                        return 1 / (1 + Math.pow(Math.E, -x));
                    },
                    derivative: function(x) {
                        var t = ActivationFunctions.sigmoid.calc(x);
                        return t * (1-t);
                    }
                },
                relu: {
                    calc: function(x) {
                        return Math.max(0, x);
                    },
                    derivative: function(x) {
                        if (x >= 0) {
                            return 1;
                        }
                        else {
                            return 0;
                        }
                    }
                }
            };

            // Object that encapsulates a single Layer of the neural network
            Layer = {
                // Initializes the layer with random values
                init: function(inputSize, outputSize) {
                    var i,
                        j;

                    this.inputSize = inputSize; // i
                    this.outputSize = outputSize; // j

                    // init W_j,i matrix with random values
                    this.w = [];
                    for (j = 0; j < outputSize; j++) {
                        this.w[j] = [];
                        for (i = 0; i < inputSize; i++) {
                            this.w[j][i] = Math.random();
                        }
                    }

                    // init b_j to zero
                    this.b = [];
                    for (j = 0; j < outputSize; j++) {
                        this.b[j] = 0;
                    }

                    // set activation function to Sigmoid as default
                    this.setActivationFunction(ActivationFunctions.sigmoid);
                },

                // Sets an activation function
                setActivationFunction: function(phi) {
                    this.phi = phi;
                },

                // Calculate intermediate values (x-tilde)
                calculateIntermediates: function(input) {
                    var i,
                        j,
                        intermediates = [];

                    if (input.length !== this.inputSize) {
                        throw new Error('Expected input of size ' + this.inputSize + ', got input of size ' + input.length + '.');
                    }

                    for (j = 0; j < this.outputSize; j++) {
                        intermediates[j] = 0;
                        for (i = 0; i < this.inputSize; i++) {
                            intermediates[j] += this.w[j][i] * input[i];
                        }
                        intermediates[j] += this.b[j];
                    }

                    // store input and intermediates
                    this.input = input;
                    this.intermediates = intermediates;

                    return intermediates;
                },

                // Forward propagation
                forward: function(input) {
                    var j,
                        intermediates = this.calculateIntermediates(input),
                        output = [];
                    for (j = 0; j < this.outputSize; j++) {
                        output[j] = this.phi.calc(intermediates[j]);
                    }
                    return output;
                },

                // Back propagation
                back: function(v) {
                    var j,
                        intermediates = this.intermediates,
                        phiv = [];

                    if (v.length !== this.outputSize) {
                        throw new Error('Expected error vector of size ' + this.outputSize + ', got size ' + v.length + '.');
                    }
                    if (!this.input) {
                        throw new Error('Please run the forward propagation first.');
                    }

                    // 0. Calculate the Hadamard product of phi' and v ("phiv")
                    for (j = 0; j < this.outputSize; j++) {
                        phiv[j] = this.phi.derivative(intermediates[j]) * v[j];
                    }

                    // 1. Calculate dW
                    this.dW = HelperFunctions.outerProduct(phiv, this.input);

                    // 2. Calculate db
                    this.db = phiv;

                    // Propagate error
                    return HelperFunctions.innerProduct(this.w, phiv);
                },

                // Parameter update
                update: function(tau) {
                    var i,
                        j,
                        wnew,
                        bnew;

                    this.backup = {}
                    this.backup.w = this.w;
                    this.backup.b = this.b;

                    wnew = new Array(this.outputSize);
                    for (j = 0; j < this.outputSize; j++) {
                        wnew[j] = new Array(this.inputSize);
                        for (i = 0; i < this.inputSize; i++) {
                            wnew[j][i] = this.w[j][i] - (tau * this.dW[j][i]);
                        }
                    }
                    this.w = wnew;

                    bnew = new Array(this.outputSize);
                    for (j = 0; j < this.outputSize; j++) {
                        bnew[j] = this.b[j] - (tau * this.db[j]);
                    }
                    this.b = bnew;
                },

                // Parameter update undo
                undo: function() {
                    this.w = this.backup.w;
                    this.b = this.backup.b;
                },

                // Perform regularization of dW
                regularization: function(l, lambda) {
                    var i,
                        j,
                        regularizationTerm;

                    regularizationTerm = function(x) {
                        // L1 regularization
                        if (l === 1) {
                            return x;
                        }
                        // L2 regularization
                        if (l === 2) {
                            return 1 / Math.sqrt(Math.pow(x, 2) + 0.0001);
                        }
                        throw new Error('Only L1 and L2 regularization is implemented.')
                    };

                    for (j = 0; j < this.outputSize; j++) {
                        for (i = 0; i < this.inputSize; i++) {
                            this.dW[j][i] += lambda * regularizationTerm(this.w[j][i]);
                        }
                    }
                }
            };

            NeuralNetwork = {
                // Set up a new neural network.
                // Specify the sizes of the layers as arguments to this function.
                // The first argument is the size of the input.
                // e.g.: nn.init(1, 2, 1)
                init: function() {
                    var k;

                    if (arguments.length < 2) {
                        throw new Error('You need to specify at least the input size and the size of one layer.');
                    }

                    this.layers = new Array(arguments.length - 1);
                    for (k = 1; k < arguments.length; k++) {
                        this.layers[k-1] = Object.create(Layer);
                        this.layers[k-1].init(arguments[k-1], arguments[k]);
                    }

                    console.log('Initialized a neural network with ' + (k-1) + ' layers:');
                    console.log(this.layers);
                },

                // Forward propagation
                forward: function(input) {
                    var k,
                        outputs = [];

                    if (!this.layers) {
                        throw new Error('You need to initialize the neural network first.');
                    }
                    console.log('Forward propagation')

                    for (k = 0; k < this.layers.length; k++) {
                        outputs[k] = this.layers[k].forward(k === 0 ? input : outputs[k-1]);
                        console.log('Output of layer k=' + k + ':');
                        console.log(outputs[k]);
                    }
                    return outputs[k];
                },

                // Back propagation
                back: function(error) {
                    var k,
                        errors = [];

                    if (!this.layers) {
                        throw new Error('You need to initialize the neural network first.');
                    }
                    console.log('Back propagation');

                    for (k = this.layers.length-1; k >= 0; k--) {
                        errors[k] = this.layers[k].back(k === (this.layers.length-1) ? error : errors[k+1]);
                        console.log('Error of layer k=' + k + ':');
                        console.log(errors[k]);
                    }
                }
            };

            // Test
            var nn = Object.create(NeuralNetwork);
            nn.init(1, 2, 3, 1);
            nn.forward([1]);
            nn.back([0.5]);
        </script>
    </body>
</html>
