<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>neural.html</title>
    </head>
    <body>
        <div id="main">
            <h1>neural.html</h1>
            <h2>A Neural Network that lives in a single HTML page.</h2>
            <p>
                Please inspect the source code of this page. You will find a neural network implementation in JavaScript
                and some examples to be run as JavaScript commands, e.g. in the JavaScript console.
            </p>
            <p>
                Furthermore here are some interactive examples:
            </p>
            <h3>Learning a cosine function</h3>
            <canvas id="cosine-chart" style="width: 100%; height: 300px;"></canvas>
        </div>

        <!-- Main code for a Neural Network in JavaScript -->
        <script>
            "use strict";
            var HelperFunctions,
                ActivationFunctions,
                Layer,
                NeuralNetwork,
                Tests;

            // Object that stores some helper functions
            HelperFunctions = {
                // calculates the outer product ab^T for two vectors a and b
                outerProduct: function(a, b) {
                    var n,
                        p,
                        result = new Array(a.length);
                    for (n = 0; n < a.length; n++) {
                        result[n] = new Array(b.length);
                        for (p = 0; p < b.length; p++) {
                            result[n][p] = a[n] * b[p];
                        }
                    }
                    return result;
                },

                // calculates the inner product a^Tb for a matrix a and a vector b
                innerProduct: function(a, b) {
                    var n,
                        p,
                        result = new Array(a[0].length);
                    for (n = 0; n < a[0].length; n++) {
                        result[n] = 0;
                        for (p = 0; p < b.length; p++) {
                            result[n] += a[p][n] * b[p];
                        }
                    }
                    return result;
                }
            };

            // Object that stores different activation functions
            ActivationFunctions = {
                sigmoid: {
                    calc: function(x) {
                        return 1 / (1 + Math.pow(Math.E, -x));
                    },
                    derivative: function(x) {
                        var t = ActivationFunctions.sigmoid.calc(x);
                        return t * (1-t);
                    }
                },
                relu: {
                    calc: function(x) {
                        return Math.max(0, x);
                    },
                    derivative: function(x) {
                        if (x >= 0) {
                            return 1;
                        }
                        else {
                            return 0;
                        }
                    }
                }
            };

            // Object that encapsulates a single Layer of the neural network
            Layer = {
                // Initializes the layer with random values
                init: function(inputSize, outputSize) {
                    var i,
                        j;

                    this.inputSize = inputSize; // i
                    this.outputSize = outputSize; // j

                    // init W_j,i matrix with random values
                    this.w = [];
                    for (j = 0; j < outputSize; j++) {
                        this.w[j] = [];
                        for (i = 0; i < inputSize; i++) {
                            this.w[j][i] = Math.random();
                        }
                    }

                    // init b_j to zero
                    this.b = [];
                    for (j = 0; j < outputSize; j++) {
                        this.b[j] = 0;
                    }

                    // set default activation function
                    this.setActivationFunction(ActivationFunctions.relu);
                },

                // Sets an activation function
                setActivationFunction: function(phi) {
                    this.phi = phi;
                },

                // Calculate intermediate values (x-tilde)
                calculateIntermediates: function(input) {
                    var i,
                        j,
                        intermediates = [];

                    if (input.length !== this.inputSize) {
                        throw new Error('Expected input of size ' + this.inputSize + ', got input of size ' + input.length + '.');
                    }

                    for (j = 0; j < this.outputSize; j++) {
                        intermediates[j] = 0;
                        for (i = 0; i < this.inputSize; i++) {
                            intermediates[j] += this.w[j][i] * input[i];
                        }
                        intermediates[j] += this.b[j];
                    }

                    // store input and intermediates
                    this.input = input;
                    this.intermediates = intermediates;

                    return intermediates;
                },

                // Forward propagation
                forward: function(input) {
                    var j,
                        intermediates = this.calculateIntermediates(input),
                        output = [];
                    for (j = 0; j < this.outputSize; j++) {
                        output[j] = this.phi.calc(intermediates[j]);
                    }
                    return output;
                },

                // Back propagation
                back: function(v) {
                    var j,
                        intermediates = this.intermediates,
                        phiv = [];

                    if (v.length !== this.outputSize) {
                        throw new Error('Expected error vector of size ' + this.outputSize + ', got size ' + v.length + '.');
                    }
                    if (!this.input) {
                        throw new Error('Please run the forward propagation first.');
                    }

                    // 0. Calculate the Hadamard product of phi' and v ("phiv")
                    for (j = 0; j < this.outputSize; j++) {
                        phiv[j] = this.phi.derivative(intermediates[j]) * v[j];
                    }

                    // 1. Calculate dW
                    this.dW = HelperFunctions.outerProduct(phiv, this.input);

                    // 2. Calculate db
                    this.db = phiv;

                    // Propagate error
                    return HelperFunctions.innerProduct(this.w, phiv);
                },

                // Parameter update
                update: function(tau) {
                    var i,
                        j,
                        wnew,
                        bnew;

                    wnew = new Array(this.outputSize);
                    for (j = 0; j < this.outputSize; j++) {
                        wnew[j] = new Array(this.inputSize);
                        for (i = 0; i < this.inputSize; i++) {
                            wnew[j][i] = this.w[j][i] - (tau * this.dW[j][i]);
                        }
                    }
                    this.w = wnew;

                    bnew = new Array(this.outputSize);
                    for (j = 0; j < this.outputSize; j++) {
                        bnew[j] = this.b[j] - (tau * this.db[j]);
                    }
                    this.b = bnew;
                },

                // Backup parameters
                // Note: This only saves references. It works for the update() function
                // which creates new arrays but won't prevent you from changing the existing arrays.
                backup: function() {
                    this.backupData = {};
                    this.backupData.w = this.w;
                    this.backupData.b = this.b;
                },

                // Parameter update undo
                undo: function() {
                    this.w = this.backupData.w;
                    this.b = this.backupData.b;
                },

                // Perform regularization of dW
                regularization: function(l, lambda) {
                    var i,
                        j,
                        regularizationTerm;

                    regularizationTerm = function(x) {
                        // L1 regularization
                        if (l === 1) {
                            return x;
                        }
                        // L2 regularization
                        if (l === 2) {
                            return 1 / Math.sqrt(Math.pow(x, 2) + 0.0001);
                        }
                        throw new Error('Only L1 and L2 regularization is implemented.')
                    };

                    for (j = 0; j < this.outputSize; j++) {
                        for (i = 0; i < this.inputSize; i++) {
                            this.dW[j][i] += lambda * regularizationTerm(this.w[j][i]);
                        }
                    }
                }
            };

            NeuralNetwork = {
                // Set up a new neural network.
                // Specify the sizes of the layers as arguments to this function.
                // The first argument is the size of the input.
                // e.g.: nn.init(1, 2, 1)
                init: function() {
                    var k;

                    if (arguments.length < 2) {
                        throw new Error('You need to specify at least the input size and the size of one layer.');
                    }

                    this.layers = new Array(arguments.length - 1);
                    for (k = 1; k < arguments.length; k++) {
                        this.layers[k-1] = Object.create(Layer);
                        this.layers[k-1].init(arguments[k-1], arguments[k]);
                    }

                    console.log('Initialized a neural network with ' + (k-1) + ' layers:');
                    console.log(this.layers);
                },

                // Sets an activation function for every layer
                setActivationFunction: function(phi) {
                    if (!this.layers) {
                        throw new Error('You need to initialize the neural network first.');
                    }

                    this.layers.forEach(function(layer) {
                        layer.setActivationFunction(phi);
                    });
                },

                // Forward propagation
                forward: function(input) {
                    var k,
                        outputs = [];

                    if (!this.layers) {
                        throw new Error('You need to initialize the neural network first.');
                    }
                    console.log('Forward propagation');
                    console.log('Input: ' + input);

                    for (k = 0; k < this.layers.length; k++) {
                        outputs[k] = this.layers[k].forward(k === 0 ? input : outputs[k-1]);
                        console.log('Output of layer k=' + k + ':');
                        console.log(outputs[k]);
                    }
                    return outputs[outputs.length-1];
                },

                // Back propagation
                back: function(error) {
                    var k,
                        errors = [];

                    if (!this.layers) {
                        throw new Error('You need to initialize the neural network first.');
                    }
                    console.log('Back propagation');

                    for (k = this.layers.length-1; k >= 0; k--) {
                        errors[k] = this.layers[k].back(k === (this.layers.length-1) ? error : errors[k+1]);
                        console.log('Error of layer k=' + k + ':');
                        console.log(errors[k]);
                    }
                },

                // Performs learning using a stochastic gradient approach
                // N: number of iterations
                // samples: training samples as an array of tuples
                // lambda: regularization parameter (>= 0)
                // tau: rate for parameter update
                // mu: alignment parameter for tau (0 < mu < 1)
                learning: function(N, samples, lambda, tau, mu) {
                    var n,
                        s,
                        output,
                        v,
                        t,
                        lastLoss = Number.POSITIVE_INFINITY,
                        curLoss;

                    if (!this.layers) {
                        throw new Error('You need to initialize the neural network first.');
                    }

                    for (n = 0; n < N; n++) {
                        console.info('Iteration ' + n);

                        // Backup current parameters
                        this.layers.forEach(function(layer) {
                            layer.backup();
                        });

                        // Reset current loss
                        curLoss = 0;

                        // For each training sample
                        for (s = 0; s < samples.length; s++) {
                            // Forward propagation
                            output = this.forward(samples[s][0]);

                            // Calculate error and loss (quadratic loss)
                            v = new Array(output.length);
                            for (t = 0; t < output.length; t++) {
                                v[t] = output[t] - samples[s][1];
                                curLoss += (0.5 * Math.pow(v[t], 2));
                            }

                            // Back propagate error into network
                            this.back(v);

                            // Regularization
                            this.layers.forEach(function(layer) {
                                layer.regularization(2, lambda); // L2 regularization
                            });

                            // Parameter update
                            this.layers.forEach(function(layer) {
                                layer.update(tau);
                            });
                        }

                        console.info('Loss: ' + curLoss);
                        if (curLoss >= lastLoss) {
                            // restore last parameters from backup
                            this.layers.forEach(function(layer) {
                                layer.undo();
                            });

                            // align tau
                            tau *= mu;
                            console.info('Aligned tau to ' + tau);
                        }
                        else {
                            lastLoss = curLoss;
                        }
                    }
                }
            };

            // Tests
            Tests = [
                // simple creation of a network, forward and backpropagation
                function() {
                    var nn = Object.create(NeuralNetwork);
                    nn.init(1, 2, 3, 1);
                    nn.forward([1]);
                    nn.back([0.5]);
                    return nn;
                },

                // a linear function (2x)
                function() {
                    var samples = [
                        [[1], [2]],
                        [[2], [4]],
                        [[3], [6]],
                        [[4], [8]],
                        [[5], [10]]
                    ];
                    var nn = Object.create(NeuralNetwork),
                        N = 10,
                        lambda = 0.1,
                        tau = 0.1,
                        mu = 0.5;
                    nn.init(1, 1);
                    nn.learning(N, samples, lambda, tau, mu);
                    return nn;
                },

                // XOR example
                function() {
                    var samples = [
                        [[0, 0], [0]],
                        [[0, 1], [1]],
                        [[1, 0], [1]],
                        [[1, 1], [0]]
                    ];
                    var nn = Object.create(NeuralNetwork),
                        N = 10,
                        lambda = 0.1,
                        tau = 0.1,
                        mu = 0.5;
                    nn.init(2, 2, 1);
                    nn.setActivationFunction(ActivationFunctions.sigmoid);
                    nn.learning(N, samples, lambda, tau, mu);
                    return nn;
                },

                // a Cosine function
                function() {
                    var nn = Object.create(NeuralNetwork),
                        N = 10,
                        lambda = 0.1,
                        tau = 0.1,
                        mu = 0.5,
                        samples = [],
                        i;
                    for (i = 0; i < 10; i += 0.1) {
                        samples[i] = [[i], [Math.cos(i)]];
                    }
                    nn.init(1, 2, 3, 1);
                    nn.learning(N, samples, lambda, tau, mu);
                    return nn;
                }
            ];
            // run tests like this:
            // Tests[3]();
        </script>

        <!-- This is only needed for the interactive chart examples: -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/1.0.2/Chart.js"></script>

        <!-- Cosine example -->
        <script>
            var nn = Tests[3]();
            var labels = [];
            var cosineData = [];
            var nnData = [];
            for (var i = 0; i < 20; i++) {
                labels[i] = i;
                cosineData[i] = Math.cos(i);
                nnData[i] = nn.forward([i])[0];
            }
            var chart = new Chart(document.getElementById('cosine-chart').getContext('2d'));
            var data = {
                labels: labels,
                datasets: [
                    {
                        label: "Cosine function",
                        fillColor: "rgba(220,220,220,0.2)",
                        strokeColor: "rgba(220,220,220,1)",
                        pointColor: "rgba(220,220,220,1)",
                        pointStrokeColor: "#fff",
                        pointHighlightFill: "#fff",
                        pointHighlightStroke: "rgba(220,220,220,1)",
                        data: cosineData
                    },
                    {
                        label: "NN output",
                        fillColor: "rgba(151,187,205,0.2)",
                        strokeColor: "rgba(151,187,205,1)",
                        pointColor: "rgba(151,187,205,1)",
                        pointStrokeColor: "#fff",
                        pointHighlightFill: "#fff",
                        pointHighlightStroke: "rgba(151,187,205,1)",
                        data: nnData
                    }
                ]
            };
            chart.Line(data, {animation: false});

        </script>
    </body>
</html>
